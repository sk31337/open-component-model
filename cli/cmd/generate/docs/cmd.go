package docs

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/spf13/cobra"
	"github.com/spf13/cobra/doc"

	"ocm.software/open-component-model/cli/internal/flags/enum"
)

const (
	FlagDirectory          = "directory"
	FlagDirectoryShortHand = "d"
	FlagMode               = "mode"
)

const (
	GenerationModeMarkdown     = "markdown"
	GenerationModeHugo         = "hugo"
	GenerationModeReStructured = "restructured"
	GenerationModeMan          = "man"
	GenerationModeYAML         = "yaml"
)

// New represents the docs command
func New() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "docs [-d <directory>] [--mode <format>]",
		Short: "Generate Documentation for the CLI",
		Long:  `Generate documentation for the OCM CLI in various formats, including Hugo-compatible markdown.`,
		RunE: func(cmd *cobra.Command, args []string) error {
			dir, err := cmd.Flags().GetString(FlagDirectory)
			if err != nil {
				return err
			}
			if dir == "" {
				if dir, err = os.Getwd(); err != nil {
					return err
				}
			}

			if err := os.MkdirAll(dir, os.ModePerm); err != nil {
				return err
			}

			mode, err := enum.Get(cmd.Flags(), FlagMode)
			if err != nil {
				return err
			}

			candidate := cmd
			for candidate.Parent() != nil {
				candidate = candidate.Parent()
			}

			switch mode {
			case GenerationModeMarkdown:
				return doc.GenMarkdownTree(candidate, dir)
			case GenerationModeHugo:
				return generateHugoMarkdown(candidate, dir)
			case GenerationModeReStructured:
				return doc.GenReSTTree(candidate, dir)
			case GenerationModeMan:
				return doc.GenManTree(candidate, &doc.GenManHeader{
					Source: "Auto generated by OCM CLI powered by spf13/cobra",
				}, dir)
			case GenerationModeYAML:
				return doc.GenYamlTree(candidate, dir)
			}

			return fmt.Errorf("unknown generation mode: %s", mode)
		},
	}
	cmd.Flags().StringP(FlagDirectory, FlagDirectoryShortHand, "", "directory to generate docs to. If not set, current working directory is used.")
	enum.Var(cmd.Flags(), FlagMode, []string{GenerationModeMarkdown, GenerationModeHugo, GenerationModeReStructured, GenerationModeMan, GenerationModeYAML}, "generation mode to use")
	return cmd
}

// hugoGenerator implements a custom cobra.doc.GenMarkdownCustom generator with Hugo frontmatter
type hugoGenerator struct {
	dir string
}

// convert standard markdown links to Hugo relref shortcodes
// (https://gohugo.io/methods/page/relref/)
func convertMarkdownLinksToRelref(content string) string {
	// match [text](filename.md) or [text](path/filename.md)
	linkRegex := regexp.MustCompile(`\[([^\]]+)\]\(([^)]+\.md)\)`)

	// Replace with Hugo relref shortcode
	result := linkRegex.ReplaceAllStringFunc(content, func(match string) string {
		// Extract text and filename from match
		parts := linkRegex.FindStringSubmatch(match)
		if parts == nil || len(parts) != 3 {
			return match // Return original if something went wrong
		}

		linkText := parts[1]
		filename := parts[2]

		// Skip external URLs (http:// or https://)
		if strings.HasPrefix(filename, "http://") || strings.HasPrefix(filename, "https://") {
			return match // Return original for external URLs
		}

		// Extract just the filename from any path (e.g., "path/file.md" -> "file.md")
		filename = filepath.Base(filename)

		// Return Hugo relref shortcode
		return fmt.Sprintf(`[%s]({{< relref "%s" >}})`, linkText, filename)
	})

	return result
}

// generateHugoMarkdownTree generates markdown documentation for a command and all its children
func generateHugoMarkdownTree(cmd *cobra.Command, generator *hugoGenerator) error {
	// Generate markdown for each command
	if err := generateHugoMarkdownForCommand(cmd, generator); err != nil {
		return err
	}

	for _, c := range cmd.Commands() {
		// Skip hidden commands
		if !c.IsAvailableCommand() || c.IsAdditionalHelpTopicCommand() {
			continue
		}
		if err := generateHugoMarkdownTree(c, generator); err != nil {
			return fmt.Errorf("failed to generate markdown for command %s: %w", c.CommandPath(), err)
		}
	}

	return nil
}

// generateHugoMarkdownForCommand generates a single markdown file for a command with Hugo frontmatter
func generateHugoMarkdownForCommand(cmd *cobra.Command, generator *hugoGenerator) error {
	// Create file name based on command path (like standard cobra markdown generator)
	basename := strings.ReplaceAll(cmd.CommandPath(), " ", "_") + ".md"
	filename := filepath.Join(generator.dir, basename)

	// Generate the markdown content
	var markdownBuffer bytes.Buffer
	if err := doc.GenMarkdown(cmd, &markdownBuffer); err != nil {
		return fmt.Errorf("failed to generate markdown for %s: %w", cmd.CommandPath(), err)
	}

	markdownContent := markdownBuffer.String()

	// Convert relative markdown links to Hugo relref shortcodes
	markdownContent = convertMarkdownLinksToRelref(markdownContent)

	// Use cmd.Short for the description
	description := cmd.Short
	if description == "" {
		description = fmt.Sprintf("Documentation for the %s command", cmd.CommandPath())
	}

	// Ensure description ends with a period
	if !strings.HasSuffix(description, ".") {
		description += "."
	}

	// Open file for writing
	f, err := os.Create(filename)
	if err != nil {
		return fmt.Errorf("failed to create file %s: %w", filename, err)
	}
	defer f.Close()

	// Generate Hugo frontmatter
	title := cmd.CommandPath()

	// Create frontmatter
	frontmatter := fmt.Sprintf(`---
title: %s
description: %s
suppressTitle: true
toc: true
sidebar:
  collapsed: true
---

`, title, description)

	// Write frontmatter to file
	if _, err := f.WriteString(frontmatter); err != nil {
		return fmt.Errorf("failed to write frontmatter to %s: %w", filename, err)
	}

	// Write the captured output to the file
	if _, err := f.WriteString(markdownContent); err != nil {
		return fmt.Errorf("failed to write markdown to %s: %w", filename, err)
	}

	return nil
}

// createHugoIndexFile creates an _index.md file for the Hugo site with only frontmatter
func createHugoIndexFile(dir string) error {
	// Create index file
	indexFile := filepath.Join(dir, "_index.md")

	// Use the fixed frontmatter as specified without any additional content
	content := `---
title: OCM CLI
description: Reference Documentation for the OCM CLI.
suppressTitle: false
toc: true
sidebar:
  collapsed: true
---
`

	// Write the index file with only the frontmatter
	if err := os.WriteFile(indexFile, []byte(content), 0o600); err != nil {
		return fmt.Errorf("failed to write _index.md: %w", err)
	}

	return nil
}

// generateHugoMarkdown generates markdown documentation with Hugo frontmatter
func generateHugoMarkdown(cmd *cobra.Command, dir string) error {
	// Create a custom generator for Hugo markdown
	hugoGen := &hugoGenerator{
		dir: dir,
	}

	// Process all commands with custom generator
	if err := generateHugoMarkdownTree(cmd, hugoGen); err != nil {
		return fmt.Errorf("failed to generate markdown: %w", err)
	}

	// Create the _index.md file (special handling)
	if err := createHugoIndexFile(dir); err != nil {
		return fmt.Errorf("failed to create index file: %w", err)
	}

	return nil
}
